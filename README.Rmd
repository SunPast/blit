---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.path = "man/figures/README-",
    out.width = "100%"
)
```

# blit: Bioinformatics Library for Integrated Tools <img src="man/figures/logo.png" alt="logo" align="right" height="140" width="120"/>

<!-- badges: start -->
[![R-CMD-check](https://github.com/WangLabCSU/blit/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/WangLabCSU/blit/actions/workflows/R-CMD-check.yaml)
[![CRAN status](https://www.r-pkg.org/badges/version/blit)](https://CRAN.R-project.org/package=blit)
[![](https://cranlogs.r-pkg.org/badges/blit)](https://cran.r-project.org/package=blit)
<!-- badges: end -->

The goal of `blit` is to make it easy to execute command line tool from R.

## Installation

You can install `blit` from `CRAN` using:
```{r, eval=FALSE}
install.packages("blit")
```

Alternatively, install the development version from
[GitHub](https://github.com/) with:
``` r
# install.packages("devtools")
devtools::install_github("WangLabCSU/blit")
```

## Example
```{r}
library(blit)
```

To build a `command`, simply use `exec`. The first argument is the command name,
and you can also provide the full path. After that, pass the command parameters.
This will create a `command` object:
```{r}
exec("echo", "$PATH")
```

To run the command, just pass the `command` object to the `cmd_run()`
```{r}
Sys.setenv(TEST = "blit is awesome")
exec("echo", "$TEST") |> cmd_run()
```

Alternatively, you can run it in the background. In this case, a
[`process`](https://processx.r-lib.org/index.html) object will be returned. For
more information, refer to the official site:
```{r eval=FALSE}
proc <- exec("echo", "$TEST") |> cmd_background(stdout = "")
proc$kill()
Sys.unsetenv("TEST")
```

> We use some tricks to capture the output from the background process. The
actual implementation in the `README.Rmd` differs, but the output remains the
same.

```{r echo=FALSE}
file <- tempfile()
proc <- exec("echo", "$TEST") |> cmd_background(stdout = file)
cat(readLines(file), sep = "\n")
Sys.unsetenv("TEST")
```

`cmd_background()` is provided for completeness. Instead of using this function,
we recommend using `cmd_parallel()`, which can run multiple commands in the
background while ensuring that all processes are properly cleaned up when the
process exits.
```{r}
# ip address are copied from quora <What are some famous IP addresses?>: https://qr.ae/pYlnbQ
cmd_parallel(
    exec("ping", "localhost"),
    exec("ping", "208.67.222.222"), # OpenDNS
    exec("ping", "8.8.8.8"), # google dns
    exec("ping", "8.8.4.4"), # google dns
    stdouts = TRUE,
    stdout_callbacks = lapply(
        seq_len(4),
        function(i) {
            force(i)
            function(text, proc) {
                sprintf("Connection %d: %s", i, text)
            }
        }
    ),
    timeouts = 4, # terminate after 4s
    threads = 4
)
```

Several functions allow you to control the environment when running the command:

  - `cmd_wd`: define the working directory.
  - `cmd_envvar`: define the environment variables.
  - `cmd_envpath`: define the `PATH`-like environment variables.

```{r}
exec("echo", "$TEST") |>
    cmd_envvar(TEST = "blit is very awesome") |>
    cmd_run()
```

`blit` provides several built-in functions for directly executing specific
commands., these include:
[samtools](https://www.htslib.org/),
[alleleCounter](https://github.com/cancerit/alleleCount),
[cellranger](https://www.10xgenomics.com/cn/support/software/cell-ranger/latest),
[fastq_pair](https://github.com/linsalrob/fastq-pair),
[gistic2](https://broadinstitute.github.io/gistic2/),
[KrakenTools](https://github.com/jenniferlu717/KrakenTools),
[kraken2](https://github.com/DerrickWood/kraken2/wiki/Manual),
[perl](https://www.perl.org/), [pySCENIC](https://github.com/aertslab/pySCENIC),
[python](https://www.python.org/), [seqkit](https://bioinf.shenwei.me/seqkit/),
[trust4](https://github.com/liulab-dfci/TRUST4).

For these commands, you can also use `cmd_help()` to print the help document.
```{r}
python() |> cmd_help()
```

```{r}
perl() |> cmd_help()
```

And it is very easily to extend for other commands.

One of the great features of `blit` is its ability to translate the R pipe
(`%>%` or `|>`) into the Linux pipe (`|`). All functions used to create a
`command` object can accept another `command` object. The internal will capture
the first unnamed input value. If it is a `command` object, it will be removed
from the call and saved. When the `command` object is run, the saved command
will be passed through the pipe (`|`) to the command. Here we take the `gzip`
command as an example (assuming you're using a Linux system).

```{r}
tmpdir <- tempdir()
file <- tempfile(tmpdir = tmpdir)
writeLines(letters, con = file)
file2 <- tempfile()
exec("gzip", "-c", file) |>
    exec("gzip", "-d", ">", file2) |>
    cmd_run()
identical(readLines(file), readLines(file2))
```

In the last we clean the temporary files.
```{r}
file.remove(file)
file.remove(file2)
```

## Development
To add a new command, use the `make_command` function. This helper function is
designed to assist developers in creating functions that initialize new
`command` objects. A `command` object is a bundle of multiple `Command` R6
objects (note the uppercase `"C"` in `Command`, which distinguishes it from the
`command` object) and the associated running environment (including the working
directory and environment variables).

The `make_command` function accepts a function that initializes a new `Command`
object and, when necessary, validates the input arguments. The core purpose is
to create a new `Command` R6 object, so familiarity with the R6 class system is
essential.

There are several private methods or fields you may want to override when
creating a new `Command` R6 object. The first method is `command_locate`, which
determines how to locate the command path. By default, it will attempt to use
the `cmd` argument provided by the user. If no `cmd` argument is supplied, it
will try to locate the command using the `name` and `alias` fields.  In most
cases, you will only need to provide values for the `name` and `alias` fields,
rather than overriding the `command_locate` method.

For example, consider the `ping` command. Here is how you can define it:
```{r, error = TRUE}
Ping <- R6::R6Class(
    "Ping",
    inherit = Command,
    private = list(name = "ping")
)
ping <- make_command("ping", function(..., ping = NULL) {
    Ping$new(cmd = ping, ...)
})
ping("8.8.8.8") |> cmd_run(timeout = 5) # terminate it after 5s
```

For the `ping` command, the `name` field is sufficient. However, for programs
that have multiple names (like `python`), you can also provide the `alias`
(`c("python2", "python3")`) field. Refer to the `cmd-python.R` script for more
details.

For command-line tools, the input parameters should always be characters. The
core principle of the `Command` object is to convert all R objects (such as data
frames) into charactersâ€”typically file paths of R objects that have been saved
to disk.


## Session Informations
```{r}
sessionInfo()
```
